// =======================================================
// brainKnowledgeEngine.js
// محرك المعرفة لنوفا بوت v3
// =======================================================

const fetch = require("node-fetch");

let knowledgeCache = {
  loaded: false,
  timestamp: 0,
  data: []
};

// تنظيف عنصر المعرفة
function normalizeItem(item) {
  if (!item) return null;
  return {
    title: (item.title || "").trim(),
    url: (item.url || "").trim(),
    description: (item.description || "").trim(),
    excerpt: (item.excerpt || "").trim()
  };
}

// -------------------------------------------------------
// تحميل JSON من Google Drive
// -------------------------------------------------------
async function loadDriveJSON(config) {
  if (!config.KNOWLEDGE.DRIVE_JSON.URL) return [];

  const res = await fetch(config.KNOWLEDGE.DRIVE_JSON.URL);
  if (!res.ok) throw new Error("Drive JSON failed");

  const json = await res.json();
  if (!Array.isArray(json)) return [];

  return json.map(normalizeItem).filter(x => x && x.title);
}

// -------------------------------------------------------
// تحميل sitemap ثم استخراج صفحات الموقع
// -------------------------------------------------------
async function loadSitemap(config) {
  if (!config.KNOWLEDGE.SITEMAP.URL) return [];

  const xmlRes = await fetch(config.KNOWLEDGE.SITEMAP.URL);
  if (!xmlRes.ok) return [];

  const xml = await xmlRes.text();
  const urls = Array.from(xml.matchAll(/<loc>(.*?)<\/loc>/g)).map(m => m[1]);

  const results = [];
  for (let url of urls) {
    try {
      const page = await fetch(url);
      const html = await page.text();

      const title = (html.match(/<title>(.*?)<\/title>/)?.[1] || "").trim();
      const desc = (html.match(/<meta name="description" content="(.*?)"/)?.[1] || "").trim();

      const firstP = (html.match(/<p[^>]*>(.*?)<\/p>/)?.[1] || "").trim();

      results.push(
        normalizeItem({
          title,
          url,
          description: desc,
          excerpt: firstP
        })
      );
    } catch (e) {}
  }

  return results.filter(x => x && x.title);
}

// -------------------------------------------------------
// Fallback مدمج
// -------------------------------------------------------
function loadEmbeddedFallback(config) {
  const items = config.KNOWLEDGE.EMBEDDED_FALLBACK.ITEMS || [];
  return items.map(normalizeItem).filter(x => x && x.title);
}


// -------------------------------------------------------
// تحميل المعرفة كاملة
// -------------------------------------------------------
async function loadKnowledge(config) {
  const ttl = config.KNOWLEDGE.CACHE.TTL_MS;

  if (knowledgeCache.loaded && Date.now() - knowledgeCache.timestamp < ttl) {
    return;
  }

  let collected = [];

  // سلسلة الأولويات
  for (const source of config.KNOWLEDGE.PRIORITY_CHAIN) {
    try {
      if (source === "drive-json" && config.KNOWLEDGE.DRIVE_JSON.ENABLED) {
        const d = await loadDriveJSON(config);
        collected = collected.concat(d);
      }

      if (source === "sitemap-scrape" && config.KNOWLEDGE.SITEMAP.ENABLED) {
        const s = await loadSitemap(config);
        collected = collected.concat(s);
      }

      if (source === "embedded-fallback" && config.KNOWLEDGE.EMBEDDED_FALLBACK.ENABLED) {
        const e = loadEmbeddedFallback(config);
        collected = collected.concat(e);
      }

    } catch (e) {
      console.warn("⚠ Knowledge source failed:", e.message);
    }
  }

  knowledgeCache = {
    loaded: true,
    timestamp: Date.now(),
    data: collected
  };
}

// -------------------------------------------------------
// أفضل تطابق
// -------------------------------------------------------
function findBestMatch(question) {
  if (!knowledgeCache.data.length) {
    return { match: null, score: 0 };
  }

  const q = question.toLowerCase();

  let best = null;
  let bestScore = 0;

  for (const item of knowledgeCache.data) {
    const hay = `${item.title} ${item.description} ${item.excerpt}`.toLowerCase();

    let score = 0;
    q.split(" ").forEach((word) => {
      if (word.length >= 3 && hay.includes(word)) score++;
    });

    if (score > bestScore) {
      bestScore = score;
      best = item;
    }
  }

  return {
    match: best,
    score: bestScore / Math.max(3, question.split(" ").length)
  };
}

function getCount() {
  return knowledgeCache.data.length;
}

module.exports = {
  loadKnowledge,
  findBestMatch,
  getCount
};
